package com.tiles.auth.dto.request;

import jakarta.validation.constraints.NotBlank;
import lombok.Data;

/**
 * Login Request DTO
 *
 * Data Transfer Object для POST /auth/login endpoint.
 *
 * DTO PATTERN:
 * ═══════════
 * DTO = Data Transfer Object
 *
 * Purpose:
 * - Separate API contract від domain model
 * - Validation at API boundary
 * - Version API independently від entities
 * - Security (don't expose entity structure)
 *
 * Benefits:
 * ✅ Clean API (only needed fields)
 * ✅ Validation (@Valid annotation)
 * ✅ Documentation (clear request format)
 * ✅ Security (no accidental data exposure)
 * ✅ Flexibility (can change entity без breaking API)
 *
 * VALIDATION:
 * ══════════
 * Jakarta Bean Validation (JSR 380).
 *
 * Annotations:
 * - @NotBlank: Cannot be null, empty, або whitespace
 * - @Size: Length constraints
 * - @Email: Email format
 * - @Pattern: Regex pattern
 * - тощо
 *
 * Validation triggered by:
 * @Valid annotation в controller:
 *
 * @PostMapping("/login")
 * public ResponseEntity<?> login(@Valid @RequestBody LoginRequest request)
 *
 * If validation fails:
 * - MethodArgumentNotValidException thrown
 * - GlobalExceptionHandler catches it
 * - Returns 400 Bad Request з error details
 *
 * LOMBOK:
 * ══════
 * @Data generates:
 * - Getters (getUsername(), getPassword())
 * - Setters (setUsername(), setPassword())
 * - toString() (for logging)
 * - equals() / hashCode()
 * - Constructor
 *
 * Why @Data (not @Getter/@Setter):
 * ✅ Less boilerplate
 * ✅ Complete POJO
 * ✅ JSON serialization works
 *
 * FIELDS:
 * ══════
 * Only fields needed для login:
 * - username (or email)
 * - password (plain text, will be validated)
 *
 * NOT included:
 * ❌ User ID (generated by system)
 * ❌ Roles (assigned by system)
 * ❌ Timestamps (automatic)
 *
 * SECURITY:
 * ════════
 * Password transmitted:
 * ⚠️  ALWAYS use HTTPS (TLS encryption)
 * ⚠️  Never log password (even hash)
 * ⚠️  Clear від memory після use
 *
 * Best practices:
 * ✅ HTTPS only (no HTTP)
 * ✅ Rate limiting (prevent brute-force)
 * ✅ Account lockout (too many failures)
 * ✅ Logging (attempts, not passwords)
 *
 * JSON FORMAT:
 * ═══════════
 * Request body:
 * {
 *   "username": "admin",
 *   "password": "password123"
 * }
 *
 * or with email:
 * {
 *   "username": "admin@example.com",
 *   "password": "password123"
 * }
 *
 * @author snowfallen
 * @version 1.0.0
 * @since 2024-10-31
 */
@Data
public class LoginRequest {

    /**
     * Username or Email
     *
     * User's login identifier.
     *
     * FLEXIBLE INPUT:
     * ══════════════
     * Field named "username", але accepts:
     * - Username: "admin"
     * - Email: "admin@example.com"
     *
     * UserService.loadUserByUsername() tries both:
     * 1. Find by username
     * 2. If not found, find by email
     *
     * Why flexible:
     * ✅ Better UX (users choose preference)
     * ✅ Common pattern (many sites support this)
     * ✅ Email memorable (vs username)
     *
     * VALIDATION:
     * ══════════
     * @NotBlank:
     * - Cannot be null
     * - Cannot be empty string ("")
     * - Cannot be whitespace only ("   ")
     *
     * Why @NotBlank (not @NotNull або @NotEmpty):
     * ✅ Catches whitespace-only input
     * ✅ Trims input automatically
     * ✅ Most restrictive validation
     *
     * Error message:
     * "Username is required"
     *
     * Returned в validation error response:
     * {
     *   "timestamp": "2024-10-31T12:30:00",
     *   "status": 400,
     *   "error": "Bad Request",
     *   "message": "Validation failed",
     *   "validationErrors": {
     *     "username": "Username is required"
     *   }
     * }
     *
     * NO FORMAT VALIDATION:
     * ════════════════════
     * We don't validate:
     * - Username format (letters, numbers, тощо)
     * - Email format
     *
     * Why:
     * - Flexible input (username OR email)
     * - Backend determines if exists
     * - Don't leak info (username enumeration)
     *
     * Security consideration:
     * Generic error message prevents username enumeration:
     * "Invalid username or password" (not "Username not found")
     */
    @NotBlank(message = "Username is required")
    private String username;

    /**
     * Password (Plain Text)
     *
     * User's password для authentication.
     *
     * PLAIN TEXT:
     * ══════════
     * Transmitted як plain text (в JSON).
     *
     * SECURITY MEASURES:
     * ═════════════════
     * ⚠️  CRITICAL: Must use HTTPS
     * - TLS encrypts transmission
     * - Cannot intercept password
     * - Certificate validation
     *
     * ⚠️  Never log password:
     * - Not in application logs
     * - Not in access logs
     * - Not in error messages
     *
     * ⚠️  Clear від memory:
     * - Use char[] instead of String (future improvement)
     * - Clear array після use
     * - String immutable (stays в memory)
     *
     * PASSWORD HASHING:
     * ════════════════
     * Flow:
     * 1. Client sends plain password (HTTPS)
     * 2. Server receives plain password
     * 3. Spring Security compares:
     *    passwordEncoder.matches(plain, hash)
     * 4. Plain password discarded
     * 5. Never stored
     *
     * BCrypt comparison:
     * - Extracts salt від stored hash
     * - Hashes plain password з same salt
     * - Compares hashes (constant-time)
     * - Returns boolean
     *
     * VALIDATION:
     * ══════════
     * @NotBlank:
     * - Cannot be null
     * - Cannot be empty
     * - Cannot be whitespace only
     *
     * Error message:
     * "Password is required"
     *
     * NO COMPLEXITY VALIDATION:
     * ════════════════════════
     * We don't validate password strength here:
     * - No minimum length check
     * - No special characters check
     * - No uppercase/lowercase check
     *
     * Why:
     * - Login accepts ANY password (will be checked)
     * - Complexity enforced at registration
     * - Don't hint about password policy
     *
     * Registration has validation:
     * @Size(min=8, message="Password must be at least 8 characters")
     *
     * SECURITY BEST PRACTICES:
     * ═══════════════════════
     * ✅ HTTPS only (TLS 1.2+)
     * ✅ Rate limiting (max 5 attempts/minute)
     * ✅ Account lockout (10 failed attempts)
     * ✅ Generic error messages (no username hints)
     * ✅ Log attempts (audit trail)
     * ✅ Monitor for brute-force
     * ✅ Consider 2FA (future)
     *
     * COMMON ATTACKS:
     * ══════════════
     * Brute-force:
     * - Try many passwords
     * - Mitigation: Rate limiting, lockout
     *
     * Credential stuffing:
     * - Use leaked passwords від other sites
     * - Mitigation: Breach detection, unique passwords
     *
     * Man-in-the-middle:
     * - Intercept password
     * - Mitigation: HTTPS, certificate pinning
     *
     * Username enumeration:
     * - Determine if username exists
     * - Mitigation: Generic error messages, same timing
     */
    @NotBlank(message = "Password is required")
    private String password;
}