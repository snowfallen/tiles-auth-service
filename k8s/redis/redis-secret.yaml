# ════════════════════════════════════════════════════════════════
# REDIS SECRET
# ════════════════════════════════════════════════════════════════
#
# Sensitive credentials для Redis
#
# ⚠️  SECURITY WARNING (same як PostgreSQL):
# - Example password only (change в production)
# - Never commit to Git (use Sealed Secrets)
# - Rotate regularly (every 90 days)

apiVersion: v1
kind: Secret

metadata:
  name: auth-redis-secret
  namespace: tiles-infra
  labels:
    app: auth-redis
    component: cache

type: Opaque

stringData:
  REDIS_PASSWORD: redis_password_change_me_in_prod
    # ═══════════════════════════════════════════════════
    # REDIS PASSWORD
    # ═══════════════════════════════════════════════════
    #
    # ⚠️⚠️⚠️ CHANGE IN PRODUCTION ⚠️⚠️⚠️
    #
    # Same security considerations як PostgreSQL:
    # - This is EXAMPLE password
    # - Weak (dictionary word)
    # - Public (в documentation)
    #
    # Production requirements:
    # ✅ 16+ characters
    # ✅ Random (generated)
    # ✅ Complex (letters, numbers, symbols)
    # ✅ Unique (not reused)
    # ✅ Rotated (every 90 days)
    #
    # Generate strong password:
    # openssl rand -base64 32
    # → Output: xT9mK2pR5nV8sW1fG4hJ7cL3bD6eQ0zA
    #
    # Why password important:
    # ══════════════════════
    # Redis = in-memory database
    # Contains sensitive data:
    # - Refresh tokens (user sessions)
    # - Session data (user info)
    # - Cache (potentially sensitive)
    #
    # If compromised:
    # ❌ Attacker reads tokens (impersonate users)
    # ❌ Attacker writes data (poison cache)
    # ❌ Attacker deletes data (DoS attack)
    #
    # Protection layers:
    # ✅ Password (authentication)
    # ✅ ClusterIP (no external access)
    # ✅ Network policies (optional firewall)
    # ✅ RBAC (limit Secret access)
    #
    # Usage в application:
    # ══════════════════════
    # Spring Boot:
    # spring:
    #   data:
    #     redis:
    #       host: auth-redis
    #       port: 6379
    #       password: ${REDIS_PASSWORD}
    #
    # Jedis:
    # JedisPool pool = new JedisPool(
    #     new JedisPoolConfig(),
    #     "auth-redis",
    #     6379,
    #     2000,
    #     password
    # );
    #
    # Lettuce:
    # RedisStandaloneConfiguration config =
    #     new RedisStandaloneConfiguration();
    # config.setHostName("auth-redis");
    # config.setPort(6379);
    # config.setPassword(RedisPassword.of(password));
    #
    # redis-cli:
    # redis-cli -h auth-redis -p 6379 -a password
    # → Manual connection (debugging)
    #
    # Connection string format:
    # redis://:password@host:port/db
  # redis://:password@auth-redis:6379/0

  REDIS_URL: redis://:redis_password_change_me_in_prod@auth-redis.tiles-infra.svc.cluster.local:6379
    # ═══════════════════════════════════════════════════
    # REDIS CONNECTION URL
    # ═══════════════════════════════════════════════════
    #
    # Complete Redis connection string
    #
    # Format:
    # redis://[:password@]host[:port][/database]
    #
    # Components:
    # - redis:// Protocol (scheme)
    # - : Empty username (Redis has no users)
    # - redis_password_change_me_in_prod: Password
    # - @ Separator
    # - auth-redis.tiles-infra.svc.cluster.local: Host (full DNS)
    # - 6379: Port
    # - /0: Database number (default DB 0)
    #
    # Why empty username:
    # Redis (< 6.0):
    # - No user concept (single password)
    # - Username field empty
    #
    # Redis 6.0+ (ACL):
    # - Multiple users possible
    # - Format: redis://username:password@host:port
    # - Example: redis://app_user:pass@host:6379
    #
    # Our config: No username (simple password)
    # - Compatible з Redis 5.x-7.x
    # - Standard practice
    #
    # Database number:
    # ═══════════════
    # /0 = Database 0 (default)
    # /1 = Database 1
    # /15 = Database 15
    #
    # Redis has 16 databases (0-15)
    # Most apps use DB 0 only
    #
    # URL encoding:
    # ════════════
    # Special characters must be encoded:
    # - @ → %40
    # - : → %3A
    # - / → %2F
    # - # → %23
    #
    # Example password: p@ss#word
    # Encoded: p%40ss%23word
    # URL: redis://:p%40ss%23word@host:6379
    #
    # Why provided:
    # ════════════
    # - Convenience (single variable)
    # - Some libraries prefer URLs
    # - Standard format (universal)
    #
    # Not required:
    # - Application uses individual env vars
    # - Provided для reference only
    #
    # TLS variant:
    # ===========
    # rediss:// (note: double 's')
    # rediss://:password@host:6380
    # → Encrypted connection (TLS)
    #
    # Production (optional TLS):
    # rediss://:password@auth-redis:6380?ssl_cert_reqs=required
    #
    # Benefits:
    # ✅ Encrypted transit (confidentiality)
    # ✅ Certificate validation (authenticity)
    # ✅ Protection від MITM attacks
    #
    # Trade-offs:
    # ⚠️  Overhead (encryption/decryption)
    # ⚠️  Complexity (certificate management)
    # ⚠️  Performance (5-10% slower)
    #
    # When to use TLS:
    # ✅ Public networks (untrusted)
    # ✅ Compliance requirements (PCI-DSS)
    # ✅ Multi-tenant (shared infrastructure)
    #
    # When to skip TLS:
    # ✅ Private network (Kubernetes cluster)
    # ✅ Performance critical (minimal latency)
    # ✅ Simple setup (development)
    #
    # Our choice: No TLS
    # - Internal network (trusted)
    # - ClusterIP (no external exposure)
    # - Performance (low latency)
    #
    # Add TLS для production (if needed):
    # - Generate certificates
    # - Configure Redis TLS
    # - Update connection URL
  # - Restart services

# ════════════════════════════════════════════════════════════════
# SECRET SECURITY (same practices як PostgreSQL)
# ════════════════════════════════════════════════════════════════
#
# Sealed Secrets (production):
# kubeseal -f auth-redis-secret.yaml -w auth-redis-sealed.yaml
#
# External Secrets (cloud):
# AWS Secrets Manager, Google Secret Manager, Azure Key Vault
#
# HashiCorp Vault (enterprise):
# Dynamic secrets, automatic rotation, audit logging
#
# RBAC (access control):
# Limit who can read this secret
#
# Rotation (regular updates):
# Every 90 days (best practice)
