# ════════════════════════════════════════════════════════════════
# POSTGRESQL SECRET
# ════════════════════════════════════════════════════════════════
#
# Sensitive credentials для PostgreSQL
#
# ⚠️  SECURITY WARNING:
# This file contains plain-text password (example only)
#
# PRODUCTION REQUIREMENTS:
# ═══════════════════════
# ❌ NEVER commit secrets to Git
# ❌ NEVER use example passwords
# ❌ NEVER store unencrypted
#
# ✅ USE Sealed Secrets (Bitnami)
# ✅ USE External Secrets Operator
# ✅ USE HashiCorp Vault
# ✅ USE Cloud secret managers (AWS Secrets Manager, Google Secret Manager)
#
# This example показує structure only
# Replace з secure secret management

apiVersion: v1
kind: Secret

metadata:
  name: auth-postgres-secret
  # ═══════════════════════════════════
  # Secret Name
  # ═══════════════════════════════════
  #
  # Referenced в Deployment:
  # env:
  #   - name: POSTGRES_PASSWORD
  #     valueFrom:
  #       secretKeyRef:
  #         name: auth-postgres-secret  ← This
  #         key: POSTGRES_PASSWORD

  namespace: tiles-infra

  labels:
    app: auth-postgres
    component: database

type: Opaque
# Generic key-value secret

stringData:
  # ════════════════════════════════════════════════════════
  # STRING DATA (plain text, auto-encoded)
  # ════════════════════════════════════════════════════════

  POSTGRES_PASSWORD: auth_password_change_me_in_prod
    # ═══════════════════════════════════════════════════
    # DATABASE PASSWORD
    # ═══════════════════════════════════════════════════
    #
    # ⚠️⚠️⚠️ CRITICAL SECURITY ⚠️⚠️⚠️
    #
    # This is EXAMPLE password only!
    # MUST change в production!
    #
    # Current password:
    # - Weak (dictionary word)
    # - Public (в documentation)
    # - Insecure (no complexity)
    #
    # PASSWORD REQUIREMENTS (Production):
    # ══════════════════════════════════
    # ✅ Length: 16+ characters
    # ✅ Uppercase letters (A-Z)
    # ✅ Lowercase letters (a-z)
    # ✅ Numbers (0-9)
    # ✅ Special characters (!@#$%^&*)
    # ✅ Random (generated, not chosen)
    # ✅ Unique (not reused)
    # ✅ Rotated (every 90 days)
    #
    # GENERATION:
    # ══════════
    # Strong random password:
    #
    # OpenSSL:
    # openssl rand -base64 32
    # → Output: cN5bXYqP8F9sK3mR7tW2vJ4nL6hD9fA1gE8cB0zX=
    #
    # Python:
    # python3 -c "import secrets; print(secrets.token_urlsafe(32))"
    # → Output: 8mKp3_nR2xV9sW4fG7hJ5tL1cD6bE9zQ0yA
    #
    # pwgen:
    # pwgen -s 32 1
    # → Output: Kf8mN2pR9xV4sW7tL3hJ6cD1bE5zQ0yA
    #
    # Password manager:
    # - 1Password (generate password)
    # - LastPass (generate password)
    # - Bitwarden (generate password)
    #
    # Example strong password:
    # aB3$fG7#jK9@nP2%rT5^vX8&zC1!dE4*
    #
    # ⚠️  Special characters escaping:
    # Some characters need escaping (shell):
    # - $ (dollar) → \$
    # - ! (exclamation) → \!
    # - " (quote) → \"
    #
    # Better: Use URL-safe characters only
    # - Base64: A-Z, a-z, 0-9, +, /, =
    # - URL-safe: A-Z, a-z, 0-9, -, _
    #
    # STORAGE:
    # ═══════
    # Development (this file):
    # - Example password OK
    # - Local cluster only
    # - No sensitive data
    #
    # Production (NEVER this way):
    # ❌ Plain text в Git
    # ❌ Visible в kubectl get
    # ❌ Easy to leak
    #
    # SEALED SECRETS (Recommended):
    # ════════════════════════════
    #
    # 1. Install Sealed Secrets controller:
    # kubectl apply -f https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.24.0/controller.yaml
    #
    # 2. Install kubeseal CLI:
    # brew install kubeseal  # macOS
    # # або download від GitHub releases
    #
    # 3. Create secret (plain text):
    # kubectl create secret generic auth-postgres-secret \
    #   --from-literal=POSTGRES_PASSWORD='your-strong-password' \
    #   --dry-run=client -o yaml > secret.yaml
    #
    # 4. Seal secret (encrypt):
    # kubeseal -f secret.yaml -w sealed-secret.yaml
    #
    # 5. sealed-secret.yaml (safe для Git):
    # apiVersion: bitnami.com/v1alpha1
    # kind: SealedSecret
    # metadata:
    #   name: auth-postgres-secret
    #   namespace: tiles-infra
    # spec:
    #   encryptedData:
    #     POSTGRES_PASSWORD: AgBt8F7Y2k...  # Encrypted!
    #
    # 6. Apply sealed secret:
    # kubectl apply -f sealed-secret.yaml
    #
    # 7. Controller decrypts (cluster only):
    # SealedSecret → Secret (automatic)
    # Only cluster can decrypt (private key)
    #
    # Benefits:
    # ✅ Safe в Git (encrypted)
    # ✅ GitOps compatible
    # ✅ Easy workflow
    # ✅ Automatic sync
    #
    # EXTERNAL SECRETS OPERATOR:
    # ═════════════════════════
    #
    # Store secrets в external vault:
    # - AWS Secrets Manager
    # - Google Secret Manager
    # - Azure Key Vault
    # - HashiCorp Vault
    #
    # 1. Install operator:
    # helm repo add external-secrets https://charts.external-secrets.io
    # helm install external-secrets external-secrets/external-secrets -n external-secrets-system --create-namespace
    #
    # 2. Create SecretStore (backend config):
    # apiVersion: external-secrets.io/v1beta1
    # kind: SecretStore
    # metadata:
    #   name: aws-secrets
    #   namespace: tiles-infra
    # spec:
    #   provider:
    #     aws:
    #       service: SecretsManager
    #       region: us-east-1
    #       auth:
    #         jwt:
    #           serviceAccountRef:
    #             name: external-secrets-sa
    #
    # 3. Create ExternalSecret (mapping):
    # apiVersion: external-secrets.io/v1beta1
    # kind: ExternalSecret
    # metadata:
    #   name: auth-postgres-secret
    #   namespace: tiles-infra
    # spec:
    #   refreshInterval: 1h
    #   secretStoreRef:
    #     name: aws-secrets
    #     kind: SecretStore
    #   target:
    #     name: auth-postgres-secret
    #     creationPolicy: Owner
    #   data:
    #     - secretKey: POSTGRES_PASSWORD
    #       remoteRef:
    #         key: auth-service/postgres-password
    #
    # 4. Operator syncs secret:
    # AWS Secrets Manager → K8s Secret (automatic)
    #
    # Benefits:
    # ✅ Centralized secret management
    # ✅ Automatic rotation
    # ✅ Audit logging (cloud provider)
    # ✅ Fine-grained access control
    # ✅ Compliance (SOC2, PCI-DSS)
    #
    # HASHICORP VAULT:
    # ═══════════════
    #
    # Enterprise secret management
    #
    # 1. Install Vault:
    # helm repo add hashicorp https://helm.releases.hashicorp.com
    # helm install vault hashicorp/vault
    #
    # 2. Store secret в Vault:
    # vault kv put secret/auth-service/postgres password=your-strong-password
    #
    # 3. Vault Agent Injector (sidecar):
    # annotations:
    #   vault.hashicorp.com/agent-inject: "true"
    #   vault.hashicorp.com/role: "auth-service"
    #   vault.hashicorp.com/agent-inject-secret-postgres: "secret/auth-service/postgres"
    #
    # 4. Vault injects secret (file):
    # /vault/secrets/postgres:
    # password=your-strong-password
    #
    # 5. Application reads file:
    # POSTGRES_PASSWORD=$(cat /vault/secrets/postgres | grep password | cut -d= -f2)
    #
    # Benefits:
    # ✅ Dynamic secrets (temporary credentials)
    # ✅ Automatic rotation
    # ✅ Audit logging (detailed)
    # ✅ Encryption transit і rest
    # ✅ Multi-cloud support
    #
    # ROTATION:
    # ════════
    # Regular password rotation (security best practice)
    #
    # Schedule: Every 90 days
    #
    # Process:
    # 1. Generate new password
    # 2. Update secret (Sealed Secret або Vault)
    # 3. Restart database pod:
    #    kubectl rollout restart deployment auth-postgres
    # 4. Verify connection:
    #    kubectl exec -it auth-postgres-xxx -- psql -U auth_user -d auth_db -c "SELECT 1"
    # 5. Update application secret
    # 6. Restart application pods:
    #    kubectl rollout restart deployment auth-service
    #
    # Zero-downtime rotation:
    # 1. Create new user (temporary):
    #    CREATE USER auth_user_new WITH PASSWORD 'new-password';
    #    GRANT ALL ON DATABASE auth_db TO auth_user_new;
    # 2. Update application (use new user)
    # 3. Restart application pods
    # 4. Verify working
    # 5. Drop old user:
    #    DROP USER auth_user;
    # 6. Rename new user:
    #    ALTER USER auth_user_new RENAME TO auth_user;
    #
    # COMPROMISED PASSWORD:
    # ════════════════════
    # If password leaked:
    #
    # IMMEDIATE ACTION:
    # 1. Rotate password (emergency process)
    # 2. Check access logs (who accessed?)
    # 3. Review database audit logs
    # 4. Notify security team
    # 5. Incident response
    #
    # Prevention:
    # ✅ Never commit to Git
    # ✅ Use encrypted storage
    # ✅ Limit access (RBAC)
    # ✅ Audit logging (who read secret?)
    # ✅ Regular rotation
    #
    # KUBERNETES SECRET ENCRYPTION:
    # ════════════════════════════
    # Enable encryption at rest:
    #
    # EncryptionConfiguration:
    # apiVersion: apiserver.config.k8s.io/v1
    # kind: EncryptionConfiguration
    # resources:
    #   - resources:
    #     - secrets
    #     providers:
    #     - aescbc:
    #         keys:
    #         - name: key1
    #           secret: <base64-encoded-32-byte-key>
    #     - identity: {}
    #
    # kube-apiserver flags:
    # --encryption-provider-config=/path/to/encryption-config.yaml
    #
    # Benefits:
    # ✅ Secrets encrypted в etcd
    # ✅ Protection at rest
    # ✅ Compliance requirement
    #
    # Limitations:
    # ⚠️  Not encrypted в transit (use TLS)
    # ⚠️  Not encrypted в pod (mounted plain text)
  # ⚠️  Key management (protect encryption key!)

  DATABASE_URL: postgresql://auth_user:auth_password_change_me_in_prod@auth-postgres.tiles-infra.svc.cluster.local:5432/auth_db
    # ═══════════════════════════════════════════════════
    # CONNECTION STRING
    # ═══════════════════════════════════════════════════
    #
    # Complete PostgreSQL connection URL
    #
    # Format:
    # postgresql://user:password@host:port/database
    #
    # Components:
    # - postgresql: Protocol (scheme)
    # - auth_user: Username
    # - auth_password_change_me_in_prod: Password
    # - auth-postgres.tiles-infra.svc.cluster.local: Host
    # - 5432: Port
    # - auth_db: Database name
    #
    # ⚠️  PASSWORD В URL:
    # URL contains plain-text password
    # Same security concerns як POSTGRES_PASSWORD
    #
    # Usage:
    # ═════
    # Some applications prefer connection URL:
    #
    # Environment variable:
    # export DATABASE_URL="postgresql://..."
    #
    # Application reads:
    # String url = System.getenv("DATABASE_URL");
    # DataSource ds = new DataSource(url);
    #
    # Spring Boot (optional):
    # spring.datasource.url=${DATABASE_URL}
    #
    # vs individual fields:
    # spring.datasource.url=jdbc:postgresql://auth-postgres:5432/auth_db
    # spring.datasource.username=auth_user
    # spring.datasource.password=${POSTGRES_PASSWORD}
    #
    # Pros (URL):
    # ✅ Single variable (simpler)
    # ✅ Standard format (universal)
    # ✅ Easy migration (Heroku-style)
    #
    # Cons (URL):
    # ⚠️  Password visible (URL encoding)
    # ⚠️  Less flexible (all або nothing)
    # ⚠️  Harder to rotate (update whole URL)
    #
    # SPECIAL CHARACTERS:
    # ══════════════════
    # If password contains special chars:
    # URL encode them!
    #
    # Example password: p@ss#word!123
    # URL encoded: p%40ss%23word%21123
    #
    # Characters needing encoding:
    # - @ → %40
    # - : → %3A
    # - / → %2F
    # - ? → %3F
    # - # → %23
    # - [ → %5B
    # - ] → %5D
    # - @ → %40
    #
    # Python encoding:
    # from urllib.parse import quote
    # password = "p@ss#word!123"
    # encoded = quote(password, safe='')
    # url = f"postgresql://user:{encoded}@host:5432/db"
    #
    # Why provided:
    # - Convenience (optional usage)
    # - Heroku compatibility (DATABASE_URL standard)
    # - 12-factor app (single config URL)
    #
    # Not required:
    # Application uses individual env vars
  # This URL provided для reference only

# ════════════════════════════════════════════════════════════════
# SECRET USAGE
# ════════════════════════════════════════════════════════════════
#
# Environment variables:
# env:
#   - name: POSTGRES_PASSWORD
#     valueFrom:
#       secretKeyRef:
#         name: auth-postgres-secret
#         key: POSTGRES_PASSWORD
#
# Application connects:
# jdbc:postgresql://auth-postgres:5432/auth_db?user=auth_user&password=${POSTGRES_PASSWORD}
#
# psql (manual connection):
# kubectl exec -it auth-postgres-xxx -- psql -U auth_user -d auth_db
# Password: [enter password від secret]
#
# ════════════════════════════════════════════════════════════════
# COMMANDS
# ════════════════════════════════════════════════════════════════
#
# Create secret:
# kubectl apply -f auth-postgres-secret.yaml
#
# View secret (base64 encoded):
# kubectl get secret auth-postgres-secret -o yaml
#
# data:
#   POSTGRES_PASSWORD: YXV0aF9wYXNzd29yZF9jaGFuZ2VfbWVfaW5fcHJvZA==
#
# Decode password:
# kubectl get secret auth-postgres-secret -o jsonpath='{.data.POSTGRES_PASSWORD}' | base64 -d
# → auth_password_change_me_in_prod
#
# ⚠️  Anyone з kubectl access can decode!
# RBAC controls who can read secrets
#
# Edit secret:
# kubectl edit secret auth-postgres-secret
# → Opens editor (values base64 encoded)
#
# Delete secret:
# kubectl delete secret auth-postgres-secret
#
# ════════════════════════════════════════════════════════════════
# RBAC (Access Control)
# ════════════════════════════════════════════════════════════════
#
# Limit who can read secrets:
#
# Role (permissions):
# apiVersion: rbac.authorization.k8s.io/v1
# kind: Role
# metadata:
#   name: postgres-secret-reader
#   namespace: tiles-infra
# rules:
# - apiGroups: [""]
#   resources: ["secrets"]
#   resourceNames: ["auth-postgres-secret"]
#   verbs: ["get"]
#
# RoleBinding:
# apiVersion: rbac.authorization.k8s.io/v1
# kind: RoleBinding
# metadata:
#   name: postgres-access
#   namespace: tiles-infra
# subjects:
# - kind: ServiceAccount
#   name: auth-postgres
# - kind: User
#   name: admin
# roleRef:
#   kind: Role
#   name: postgres-secret-reader
#   apiGroup: rbac.authorization.k8s.io
#
# Result:
# ✅ auth-postgres pod can read secret
# ✅ admin user can read secret
# ❌ Other pods cannot read
# ❌ Other users cannot read
