# ════════════════════════════════════════════════════════════════
# JWT KEYS SECRET
# ════════════════════════════════════════════════════════════════
#
# Kubernetes Secret storing RSA key pair для JWT signing/validation
#
# CRITICAL SECURITY:
# ⚠️⚠️⚠️ PRIVATE KEY = MOST SENSITIVE DATA ⚠️⚠️⚠️
#
# If compromised:
# ❌ Attacker can forge JWTs (impersonate any user)
# ❌ Bypass authentication completely
# ❌ Full system breach
#
# Protection:
# ✅ Store securely (encrypted storage)
# ✅ Limit access (RBAC - only auth-service)
# ✅ Rotate regularly (every 90 days)
# ✅ Audit access (who read secret)
# ✅ Never commit to Git (use sealed secrets)

apiVersion: v1
kind: Secret
# ═══════════════
# Secret Type
# ═══════════════
#
# Secret = sensitive data storage
#
# vs ConfigMap:
# ConfigMap: Non-sensitive (URLs, config)
# Secret: Sensitive (passwords, keys, tokens)
#
# Secret features:
# ✅ Base64 encoded (obfuscation, not encryption!)
# ✅ RBAC control (who can read)
# ✅ Audit logging (access tracked)
# ✅ Encryption at rest (optional, enable!)
# ✅ Mount as files або env vars
#
# ⚠️  WARNING:
# Secrets NOT encrypted by default!
# Stored plain в etcd (Kubernetes database)
#
# Enable encryption:
# - EncryptionConfiguration
# - KMS provider (cloud)
# - External secret managers

metadata:
  name: jwt-keys-secret
  # ═══════════════════════
  # Secret Name
  # ═══════════════════════
  #
  # Referenced в Deployment:
  # env:
  #   - name: JWT_PRIVATE_KEY
  #     valueFrom:
  #       secretKeyRef:
  #         name: jwt-keys-secret  ← This
  #         key: JWT_PRIVATE_KEY

  namespace: tiles-infra
  # Same namespace як auth-service

type: Opaque
# ═══════════════════════════════════════════════════════
# SECRET TYPE
# ═══════════════════════════════════════════════════════
#
# Secret types:
# ════════════
#
# Opaque (this one):
# ✅ Generic key-value data
# ✅ Most flexible
# ✅ Any data type
# ✅ Base64 encoded
#
# Use cases:
# - Passwords
# - API tokens
# - Private keys (this)
# - Certificates (custom format)
#
# ════════════════════════════════════════════════════════
#
# kubernetes.io/tls:
# ✅ TLS certificates
# ✅ Structured (tls.crt, tls.key)
# ✅ Used by Ingress
#
# Example:
# type: kubernetes.io/tls
# data:
#   tls.crt: <base64 cert>
#   tls.key: <base64 key>
#
# ════════════════════════════════════════════════════════
#
# kubernetes.io/dockerconfigjson:
# ✅ Docker registry credentials
# ✅ Pull private images
#
# Example:
# type: kubernetes.io/dockerconfigjson
# data:
#   .dockerconfigjson: <base64 config>
#
# ════════════════════════════════════════════════════════
#
# kubernetes.io/basic-auth:
# ✅ Username/password pairs
#
# Example:
# type: kubernetes.io/basic-auth
# data:
#   username: <base64>
#   password: <base64>
#
# ════════════════════════════════════════════════════════
#
# kubernetes.io/ssh-auth:
# ✅ SSH private keys
#
# Example:
# type: kubernetes.io/ssh-auth
# data:
#   ssh-privatekey: <base64>
#
# ════════════════════════════════════════════════════════
#
# Why Opaque для JWT keys:
# ✅ Custom format (PEM keys)
# ✅ Two keys (public + private)
# ✅ Not standard TLS usage
# ✅ Flexible structure

stringData:
  # ════════════════════════════════════════════════════════
  # STRING DATA
  # ════════════════════════════════════════════════════════
  #
  # Plain text data (automatically base64 encoded)
  #
  # vs data:
  # ═══════
  #
  # stringData (this):
  # - Plain text input
  # - Automatic base64 encoding
  # - Human-readable
  # - Good для YAML files
  #
  # data:
  # - Base64 encoded input
  # - Manual encoding required
  # - Not human-readable
  # - Good для binary data
  #
  # Example stringData:
  # stringData:
  #   password: my-secret-password
  #   → Stored як: cGFzc3dvcmQ6IG15LXNlY3JldC1wYXNzd29yZA==
  #
  # Example data:
  # data:
  #   password: bXktc2VjcmV0LXBhc3N3b3Jk
  #   → Already base64 encoded
  #
  # Multi-line stringData (|):
  # stringData:
  #   key: |
  #     line 1
  #     line 2
  #     line 3
  #   → Preserves newlines і formatting

  JWT_PRIVATE_KEY: |
    # ════════════════════════════════════════════════════
    # JWT PRIVATE KEY (RSA)
    # ════════════════════════════════════════════════════
    #
    # ⚠️⚠️⚠️ MOST SENSITIVE SECRET ⚠️⚠️⚠️
    #
    # RSA private key для signing JWTs
    #
    # KEY FORMAT:
    # ══════════
    # PEM (Privacy-Enhanced Mail) format
    # Base64 encoded DER (Distinguished Encoding Rules)
    #
    # Structure:
    # -----BEGIN PRIVATE KEY-----
    # <base64 encoded key data>
    # -----END PRIVATE KEY-----
    #
    # Key components (RSA):
    # - Modulus (n): Large prime product
    # - Public exponent (e): Usually 65537
    # - Private exponent (d): Secret exponent
    # - Primes (p, q): Prime factors
    # - Exponents (dP, dQ): CRT optimization
    # - Coefficient (qInv): CRT optimization
    #
    # KEY GENERATION:
    # ══════════════
    #
    # Generate RSA 2048-bit key pair:
    # openssl genrsa -out private_key.pem 2048
    #
    # Extract public key:
    # openssl rsa -in private_key.pem -pubout -out public_key.pem
    #
    # Convert to PKCS#8 (recommended):
    # openssl pkcs8 -topk8 -nocrypt -in private_key.pem -out private_key_pkcs8.pem
    #
    # KEY SIZE:
    # ════════
    # - 1024 bits: ❌ WEAK (deprecated)
    # - 2048 bits: ✅ STANDARD (current)
    # - 4096 bits: ✅ STRONG (slower, more secure)
    #
    # Auth Service: 2048 bits
    # - Good balance (security vs performance)
    # - Industry standard
    # - Fast signing/validation (~1ms)
    #
    # USAGE:
    # ═════
    # Auth Service:
    # 1. Loads private key on startup
    # 2. Signs JWT з private key (RS256)
    # 3. JWT header: {"alg":"RS256","typ":"JWT"}
    # 4. Signature = RSA_sign(header.payload, private_key)
    #
    # Example JWT creation:
    # String jwt = Jwts.builder()
    #     .setSubject(userId)
    #     .claim("username", username)
    #     .claim("roles", roles)
    #     .setIssuer("http://auth-service:8084")
    #     .setIssuedAt(new Date())
    #     .setExpiration(expiryDate)
    #     .signWith(privateKey, SignatureAlgorithm.RS256)
    #     .compact();
    #
    # SECURITY:
    # ════════
    # ⚠️  Never expose private key:
    # ❌ Don't log
    # ❌ Don't transmit
    # ❌ Don't store в Git
    # ❌ Don't share
    #
    # ✅ Protect private key:
    # - Kubernetes Secret (this)
    # - RBAC (limit access)
    # - Encryption at rest (enable!)
    # - Audit logging (track access)
    # - Regular rotation (90 days)
    #
    # If compromised:
    # 1. Attacker can sign JWTs
    # 2. Impersonate any user
    # 3. Full system breach
    # 4. Must rotate key immediately
    # 5. Invalidate all JWTs
    #
    # Key rotation:
    # 1. Generate new key pair
    # 2. Add new key до JWKS (keep old)
    # 3. Start signing з new key
    # 4. Old tokens still valid (old key validates)
    # 5. Wait до all old tokens expired (15 min)
    # 6. Remove old key
    #
    # SEALED SECRETS (Production):
    # ═══════════════════════════
    # Don't store secrets в Git (plain text)
    #
    # Use Sealed Secrets (Bitnami):
    # 1. Encrypt secret (client-side)
    # 2. Store encrypted в Git
    # 3. Deploy encrypted secret
    # 4. Controller decrypts (cluster only)
    #
    # Install:
    # kubectl apply -f https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.24.0/controller.yaml
    #
    # Seal secret:
    # kubeseal -f jwt-keys-secret.yaml -w jwt-keys-sealed.yaml
    #
    # Result (safe для Git):
    # apiVersion: bitnami.com/v1alpha1
    # kind: SealedSecret
    # metadata:
    #   name: jwt-keys-secret
    # spec:
    #   encryptedData:
    #     JWT_PRIVATE_KEY: AgBt8F7... (encrypted)
    #
    # Benefits:
    # ✅ Safe в Git (encrypted)
    # ✅ Only cluster can decrypt
    # ✅ Same workflow (GitOps)
    #
    # EXTERNAL SECRETS (Alternative):
    # ═══════════════════════════════
    # Store secrets в external vault
    #
    # External Secrets Operator:
    # - AWS Secrets Manager
    # - Google Secret Manager
    # - HashiCorp Vault
    # - Azure Key Vault
    #
    # Example:
    # apiVersion: external-secrets.io/v1beta1
    # kind: ExternalSecret
    # metadata:
    #   name: jwt-keys-secret
    # spec:
    #   secretStoreRef:
    #     name: aws-secrets-manager
    #   target:
    #     name: jwt-keys-secret
    #   data:
    #     - secretKey: JWT_PRIVATE_KEY
    #       remoteRef:
    #         key: auth-service/jwt-private-key
    #
    # Benefits:
    # ✅ Centralized secret management
    # ✅ Automatic rotation
    # ✅ Audit logging (cloud provider)
    # ✅ Fine-grained access control
    #
    # ⚠️⚠️⚠️ PLACEHOLDER KEY BELOW ⚠️⚠️⚠️
    # Replace з your generated key!
    # This is example format only.

    -----BEGIN PRIVATE KEY-----
    MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQC7VJTUt9Us8cKj
    MzEfYyjiWA4R4/M2bS1+fWIcPm4zfYcP1O3mKfYWNhz6R0l1/YXN8VPxp8FBvG+h
    XAMPLE_PRIVATE_KEY_DATA_REPLACE_WITH_YOUR_GENERATED_KEY_THIS_IS_JUST
    A_PLACEHOLDER_FORMAT_SHOWING_THE_STRUCTURE_OF_PEM_ENCODED_RSA_PRIVATE
    KEY_FOR_DEMONSTRATION_PURPOSES_GENERATE_YOUR_OWN_KEY_USING_OPENSSL_OR
    SIMILAR_TOOLS_AND_KEEP_IT_SECURE_NEVER_COMMIT_REAL_KEYS_TO_VERSION_CO
    NTROL_USE_SEALED_SECRETS_OR_EXTERNAL_SECRET_MANAGERS_FOR_PRODUCTION_EN
    VIRONMENTS_THIS_IS_A_VERY_LONG_LINE_TO_SIMULATE_ACTUAL_KEY_DATA_WHICH
    IS_MUCH_LONGER_THAN_THIS_PLACEHOLDER_TEXT_BUT_SERVES_TO_ILLUSTRATE_TH
    E_FORMAT_AND_STRUCTURE_OF_A_TYPICAL_RSA_PRIVATE_KEY_IN_PEM_FORMAT_FO
    R_USE_WITH_JWT_SIGNING_IN_KUBERNETES_SECRETS
    -----END PRIVATE KEY-----
    #
    # ⚠️  GENERATE YOUR OWN KEY:
    # openssl genrsa -out private_key.pem 2048
    # cat private_key.pem
    # → Copy output here (including BEGIN/END lines)

  JWT_PUBLIC_KEY: |
    # ════════════════════════════════════════════════════
    # JWT PUBLIC KEY (RSA)
    # ════════════════════════════════════════════════════
    #
    # RSA public key для verifying JWTs
    #
    # KEY FORMAT:
    # ══════════
    # PEM format (same як private key)
    #
    # Structure:
    # -----BEGIN PUBLIC KEY-----
    # <base64 encoded key data>
    # -----END PUBLIC KEY-----
    #
    # Key components (RSA public):
    # - Modulus (n): Same як private key
    # - Public exponent (e): Usually 65537
    #
    # EXTRACTION:
    # ══════════
    # Derived від private key:
    # openssl rsa -in private_key.pem -pubout -out public_key.pem
    #
    # Cannot derive private від public (one-way)
    #
    # USAGE:
    # ═════
    # Auth Service:
    # 1. Publishes via JWKS endpoint
    # 2. GET /.well-known/jwks.json
    # 3. Returns public key components (n, e)
    #
    # Gateway:
    # 1. Fetches JWKS від auth-service
    # 2. Caches public key (24h)
    # 3. Validates JWT signatures:
    #    - Extract JWT signature
    #    - Verify з public key
    #    - If valid → JWT authentic
    #
    # Example validation:
    # Claims claims = Jwts.parserBuilder()
    #     .setSigningKey(publicKey)
    #     .build()
    #     .parseClaimsJws(jwt)
    #     .getBody();
    #
    # SECURITY:
    # ════════
    # Public key = safe to expose:
    # ✅ Cannot sign JWTs (need private key)
    # ✅ Only verifies signatures
    # ✅ Published publicly (JWKS)
    # ✅ Cached by clients
    #
    # Public key cryptography:
    # Private key: Signs (Auth Service only)
    # Public key: Verifies (Everyone)
    #
    # JWKS FORMAT:
    # ═══════════
    # Public key exposed як:
    # {
    #   "keys": [{
    #     "kty": "RSA",
    #     "kid": "auth-service-key-2024",
    #     "alg": "RS256",
    #     "use": "sig",
    #     "n": "<modulus base64url>",
    #     "e": "AQAB"
    #   }]
    # }
    #
    # Components:
    # n: Modulus (large number, ~2048 bits)
    # e: Exponent (usually 65537 = AQAB base64url)
    #
    # ⚠️  PLACEHOLDER KEY BELOW ⚠️
    # Replace з your generated key!

    -----BEGIN PUBLIC KEY-----
    MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAu1SU1LfVLPHCozMxH2Mo
    4lgOEePzNm0tfn1iHD5uM32HD9Tt5in2FjYc+kdJdf2FzfFT8afBQbxvoXg3BvNJ
    EXAMPLE_PUBLIC_KEY_DATA_REPLACE_WITH_YOUR_GENERATED_KEY_EXTRACTED_FRO
    M_THE_PRIVATE_KEY_USING_OPENSSL_RSA_PUBOUT_COMMAND_THIS_PUBLIC_KEY_MU
    ST_CORRESPOND_TO_THE_PRIVATE_KEY_ABOVE_FOR_PROPER_JWT_SIGNING_AND_VAL
    IDATION_THE_PUBLIC_KEY_IS_SAFE_TO_DISTRIBUTE_AND_WILL_BE_PUBLISHED_VI
    A_THE_JWKS_ENDPOINT_FOR_OTHER_SERVICES_TO_VALIDATE_JWT_SIGNATURES_THI
    S_IS_JUST_A_PLACEHOLDER_TO_SHOW_THE_EXPECTED_FORMAT_OF_THE_PUBLIC_KEY
    IN_PEM_ENCODING
    -----END PUBLIC KEY-----
    #
    # ⚠️  EXTRACT YOUR PUBLIC KEY:
    # openssl rsa -in private_key.pem -pubout -out public_key.pem
    # cat public_key.pem
    # → Copy output here (including BEGIN/END lines)

# ════════════════════════════════════════════════════════════════
# SECRET USAGE
# ════════════════════════════════════════════════════════════════
#
# Mount в Deployment:
# ══════════════════
#
# As environment variables (this config):
# env:
#   - name: JWT_PRIVATE_KEY
#     valueFrom:
#       secretKeyRef:
#         name: jwt-keys-secret
#         key: JWT_PRIVATE_KEY
#
# As files (alternative):
# volumeMounts:
#   - name: jwt-keys
#     mountPath: /etc/jwt-keys
#     readOnly: true
# volumes:
#   - name: jwt-keys
#     secret:
#       secretName: jwt-keys-secret
#
# Files created:
# /etc/jwt-keys/JWT_PRIVATE_KEY
# /etc/jwt-keys/JWT_PUBLIC_KEY
#
# Spring Boot config:
# jwt:
#   private-key: file:/etc/jwt-keys/JWT_PRIVATE_KEY
#   public-key: file:/etc/jwt-keys/JWT_PUBLIC_KEY
#
# ════════════════════════════════════════════════════════════════
# ACCESS CONTROL (RBAC)
# ════════════════════════════════════════════════════════════════
#
# Limit who can read secret:
#
# Role (permissions):
# apiVersion: rbac.authorization.k8s.io/v1
# kind: Role
# metadata:
#   name: secret-reader
#   namespace: tiles-infra
# rules:
# - apiGroups: [""]
#   resources: ["secrets"]
#   resourceNames: ["jwt-keys-secret"]
#   verbs: ["get"]
#
# RoleBinding (assign to service account):
# apiVersion: rbac.authorization.k8s.io/v1
# kind: RoleBinding
# metadata:
#   name: auth-service-secret-reader
#   namespace: tiles-infra
# subjects:
# - kind: ServiceAccount
#   name: auth-service
# roleRef:
#   kind: Role
#   name: secret-reader
#   apiGroup: rbac.authorization.k8s.io
#
# ServiceAccount (pod identity):
# apiVersion: v1
# kind: ServiceAccount
# metadata:
#   name: auth-service
#   namespace: tiles-infra
#
# Deployment uses ServiceAccount:
# spec:
#   template:
#     spec:
#       serviceAccountName: auth-service
#
# Result:
# ✅ Only auth-service pods can read secret
# ❌ Other pods cannot access
# ✅ Fine-grained access control
